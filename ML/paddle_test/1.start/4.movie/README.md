# 数据处理

- 读取用户数据，存储到字典。
- 读取电影数据，存储到字典。
- 读取评分数据，存储到字典。
- 读取海报数据，存储到字典。
- 将各个字典中的数据拼接，形成数据读取器。
- 划分训练集和验证集，生成迭代器，每次提供一个批次的数据。

## 用户数据处理

- 将性别 M、F 转成数字 0、1 表示

## 电影数据

- 统计电影名字的单词，并给每个单词一个数字序号
- 统计电影类别的单词，并给每个单词一个数字序号
- 电影类别和电影名称定长填充，并保存所有电影数据到字典中
  - 从上面两小节我们已知：最大电影名字长度是 15，最大电影类别长度是 6，15 和 6 分别表示电影名字、种类包含的最多单词数量。因此我们通过补 0 使电影名字的列表长度为 15，使电影种类的列表长度补齐为 6

## 评分数据

## 海报数据

- 海报的图片文件以"mov_id" + 电影 ID + ".jpg"的方式命名。因此，我们可以用电影 ID 去索引对应的海报图像。

# 构建数据读取器

- 利用这些处理好的数据，构建一个数据读取器，方便在训练神经网络时直接调用

# 模型设计

- 在电影推荐任务中，我们将设计一个神经网络模型，提取用户数据、电影数据的特征向量，然后计算这些向量的相似度，利用相似度的大小去完成推荐
- 神经网络模型的设计包含如下步骤：
  - 分别将用户、电影的多个特征数据转换成特征向量
    - 用户特征包含四个属性信息，分别是用户 ID、性别、职业和年龄
    - 电影特征包含三个属性信息，分别是电影 ID、电影类型和电影名称
  - 对这些特征向量，使用全连接层或者卷积层进一步提取特征
  - 将用户、电影多个数据的特征向量融合成一个向量表示，方便进行相似度计算
  - 计算特征之间的相似度
    - 衡量相似度的计算有多种方式，比如计算余弦相似度、皮尔森相关系数、Jaccard 相似系数等等，或者通过计算欧几里得距离、曼哈顿距离、明可夫斯基距离等方式计算相似度。余弦相似度是一种简单好用的向量相似度计算方式，通过计算向量之间的夹角余弦值来评估他们的相似度，本节我们使用余弦相似度计算特征之间的相似度

## 为何如此设计网络呢？

- 网络的主体框架已经在第一章中做出了分析，但还有一些细节点没有确定。

- 如何将“数字”转变成“向量”？

  - 如 NLP 章节的介绍，使用词嵌入（Embedding）的方式可将数字转变成向量。

- 如何合并多个向量的信息？例如：如何将用户四个特征（ID、性别、年龄、职业）的向量合并成一个向量？

  - 最简单的方式是先将不同特征向量（ID 32 维、性别 16 维、年龄 16 维、职业 16 维）通过 4 个全连接层映射到 4 个等长的向量（200 维度），再将 4 个等长的向量按位相加即可得到 1 个包含全部信息的向量。电影类型的特征是将多个数字（代表出现的单词）转变成的多个向量（6 个），可以通过相同的方式合并成 1 个向量。

- 如何处理文本信息？

  - 如 NLP 章节的介绍，使用卷积神经网络(CNN)和长短记忆神经网络（LSTM）处理文本信息会有较好的效果。因为电影标题是相对简单的短文本，所以我们使用卷积网络结构来处理电影标题。

- 尺寸大小应该如何设计？
  - 这涉及到信息熵的理念：越丰富的信息，维度越高。所以，信息量较少的原始特征可以用更短的向量表示，例如性别、年龄和职业这三个特征向量均设置成 16 维，而用户 ID 和电影 ID 这样较多信息量的特征设置成 32 维。综合了 4 个原始用户特征的向量和综合了 3 个电影特征的向量均设计成 200 维度，使得它们可以蕴含更丰富的信息。当然，尺寸大小并没有一贯的最优规律，需要我们根据问题的复杂程度，训练样本量，特征的信息量等多方面信息探索出最有效的设计。

## Embedding

- Embedding 是一个嵌入层，将输入的非负整数矩阵中的每个数值，转换为具有固定长度的向量
- 我们将用户和电影的特征用数字表示, 嵌入层 Embedding 可以完成数字到向量的映射

```python
class paddle.nn.Embedding (num_embeddings, embedding_dim, padding_idx=None, sparse=False, weight_attr=None, name=None)
    """
    num_embeddings (int)：表示嵌入字典的大小
    embedding_dim ：表示每个嵌入向量的大小
    sparse (bool)：是否使用稀疏更新，在词嵌入权重较大的情况下，使用稀疏更新能够获得更快的训练速度及更小的内存/显存占用
    weight_attr (ParamAttr)：指定嵌入向量的配置，包括初始化方法，具体用法请参见 ParamAttr ，一般无需设置，默认值为None
    """

embedding函数在输入Tensor shape的最后一维后面添加embedding_dim的维度，所以输出的维度数量会比输入多一个。以下面的代码为例，当输入的Tensor尺寸是[1]、embedding_dim是32时，输出Tensor的尺寸是[1,32]
```

## 用户特征网络

### 1.提取用户 ID 特征

- 使用 Embedding 将用户 ID 映射为向量
- 使用一层全连接层和 ReLU 激活函数进一步提取用户 ID 特征
- 用户 ID 只包含一个数字，数据更为简单。这里需要考虑将用户 ID 映射为多少维度的向量合适, 理论上来说，如果使用二进制表示用户 ID，用户最大 ID 是 6040，小于 2 的 13 次方，因此，理论上使用 13 维度的向量已经足够了，为了让不同 ID 的向量更具区分性，我们选择将用户 ID 映射为维度为 32 维的向量

### 2.提取用户性别特征

- 同用户 ID 特征提取步骤，使用 Embedding 层和全连接层提取用户性别特征
- 用户性别不像用户 ID 数据那样有数千数万种不同数据，性别只有两种可能，不需要使用高维度的向量表示其特征，这里我们将用户性别用为 16 维的向量表示

### 3.提取用户年龄特征

- 同样采用 Embedding 层和全连接层的方式提取特征
- 得知用户年龄最大值为 56，这里仍将用户年龄用 16 维的向量表示

### 4.提取用户职业特征

- 同样采用 Embedding 层和全连接层的方式提取特征。由上一节信息可以得知用户职业的最大数字表示是 20

### 5.融合用户特征

- 通过结合不同特征的长处，达到取长补短的目的, 简单的融合方法有：特征（加权）相加、特征级联、特征正交等等
- 此处使用特征融合是为了将用户的多个特征融合到一起，用单个向量表示每个用户，更方便计算用户与电影的相似度
- 上文使用 Embedding 加全连接的方法，分别得到了用户 ID、年龄、性别、职业的特征向量，可以使用全连接层将每个特征映射到固定长度，然后进行相加，得到融合特征
- 这里使用全连接层进一步提取特征，而不是直接相加得到用户特征的原因有两点：
  - 一是用户每个特征数据维度不一致，无法直接相加
  - 二是用户每个特征仅使用了一层全连接层，提取特征不充分，多使用一层全连接层能进一步提取特征。而且，这里用高维度（200 维）的向量表示用户特征，能包含更多的信息，每个用户特征之间的区分也更明显

## 电影特征

### 1.提取电影 ID 特征

- 与计算用户 ID 特征的方式类似
- 根据上述信息得知电影 ID 的最大值是 3952

### 2.提取电影类别特征

- 与电影 ID 数据不同的是，每个电影有多个类别，提取类别特征时，如果对每个类别数据都使用一个全连接层，电影最多的类别数是 6，会导致类别特征提取网络参数过多而不利于学习
- 我们对于电影类别特征提取的处理方式是：
  - 通过 Embedding 网络层将电影类别数字映射为特征向量
  - 对 Embedding 后的向量沿着类别数量维度进行求和，得到一个类别映射向量
  - 通过一个全连接层计算类别特征向量
- 每个电影的类别数量是不固定的，且一个电影最大的类别数量是 6，类别数量不足 6 的通过补 0 到 6 维。因此，每个类别的数据维度是 6, 每个电影类别有 6 个 Embedding 向量. 我们希望用一个向量就可以表示电影类别，可以对电影类别数量维度降维， 这里对 6 个 Embedding 向量通过求和的方式降维，得到电影类别的向量表示

### 3.提取电影名称特征

- 与电影类别数据一样，每个电影名称具有多个单词。我们对于电影名称特征提取的处理方式是
  - 通过 Embedding 映射电影名称数据，得到对应的特征向量
  - 对 Embedding 后的向量使用卷积层+全连接层进一步提取特征
  - 对特征进行降采样，降低数据维度
- 提取电影名称特征时，使用了卷积层加全连接层的方式提取特征。这是因为电影名称单词较多，最大单词数量是 15，如果采用和电影类别同样的处理方式，即沿着数量维度求和，显然会损失很多信息。考虑到 15 这个维度较高，可以使用卷积层进一步提取特征，同时通过控制卷积层的步长，降低电影名称特征的维度

### 4.融合电影特征

- 与用户特征融合方式相同，电影特征融合采用特征级联加全连接层的方式，将电影特征用一个 200 维的向量表示

# 训练

- 训练
- 验证

# 保存特征

- 流程
  - 加载预训练好的模型参数
  - 输入数据集的数据，提取整个数据集的用户特征和电影特征
  - 分别得到用户特征向量和电影特征向量
- 保存
  - pickle
  - faiss
  - milvus

# 推荐

- 根据一个电影推荐其相似的电影
- 给指定用户推荐与其喜好相似的用户喜欢的电影
- 根据用户的喜好，推荐其可能喜欢的电影
  - 1. 读取特征向量
  - 2. 计算用户和所有电影的相似度，构建相似度矩阵
  - 3. 对相似度排序，选出最大相似度












