package com.lrtz.locks;

/**
 * @author lvtao
 * @date 2020/10/8 13:09
 *
 *
 * JVM中的同步是基于进入和退出管程（Monitor）对象实现的
 * 每个Java对象实例都会有一个Monitor，Monitor可以和Java对象实例一起被创建和销毁
 * Monitor是由ObjectMonitor实现的，对应ObjectMonitor.hpp
 * 当多个线程同时访问一段同步代码时，会先被放在EntryList中
 * 当线程获取到Java对象的Monitor时（Monitor是依靠底层操作系统的Mutex Lock来实现互斥的）
 *      线程申请Mutex成功，则持有该Mutex，其它线程将无法获取到该Mutex
 * 进入WaitSet
 *      竞争锁失败的线程会进入WaitSet
 *      竞争锁成功的线程如果调用wait方法，就会释放当前持有的Mutex，并且该线程会进入WaitSet
 *      进入WaitSet的进程会等待下一次唤醒，然后进入EntryList重新排队
 * 如果当前线程顺利执行完方法，也会释放Mutex
 * Monitor依赖于底层操作系统的实现，存在用户态和内核态之间的切换，所以增加了性能开销
 *
 *
 * 锁优化
 *
 * 锁升级功能主要依赖于对象头中的Mark Word中锁标志位和是否偏向锁标志位
 * synchronized同步锁的升级优化路径：偏向锁 -> 轻量级锁 -> 重量级锁
 *
 * 1.偏向锁
 *
 *      主要用来优化同一线程多次申请同一个锁的竞争，在某些情况下，大部分时间都是同一个线程竞争锁资源
 *      当一个线程再次访问同一个同步代码时，该线程只需对该对象头的Mark Word中去判断是否有偏向锁指向它
 *      无需再进入Monitor去竞争对象（避免用户态和内核态的切换
 *
 * 当对象被当做同步锁，并有一个线程抢到锁时
 *      锁标志位还是01，是否偏向锁标志位设置为1，并且记录抢到锁的线程ID，进入_偏向锁状态_
 *
 * 偏向锁_不会主动释放锁_
 *      当线程1再次获取锁时，会比较当前线程的ID与锁对象头部的线程ID是否一致，如果一致，无需CAS来抢占锁
 *      如果不一致，需要查看锁对象头部记录的线程是否存活
 *          如果没有存活，那么锁对象被重置为无锁状态（也是一种撤销），然后重新偏向线程2
 *          如果存活，查找线程1的栈帧信息
 *              如果线程1还是需要继续持有该锁对象，那么暂停线程1（STW），撤销偏向锁，升级为轻量级锁
 *              如果线程1不再使用该锁对象，那么将该锁对象设为无锁状态（也是一种撤销），然后重新偏向线程2
 *
 * 一旦出现其他线程竞争锁资源时，偏向锁就会被撤销
 *      偏向锁的撤销可能需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法
 *      如果还没有执行完，说明此刻有多个线程竞争，升级为轻量级锁；如果已经执行完毕，唤醒其他线程继续CAS抢占
 *
 * 一旦出现其他线程竞争锁资源时，偏向锁就会被撤销
 *      偏向锁的撤销可能需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法
 *      如果还没有执行完，说明此刻有多个线程竞争，升级为轻量级锁；如果已经执行完毕，唤醒其他线程继续CAS抢占
 * 在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁会被撤销，发生STW，加大了性能开销
 *
 * 2.轻量级锁
 *  线程获取轻量级锁时会有两步
 *      先把锁对象的Mark Word复制一份到线程的栈帧中（DisplacedMarkWord），主要为了保留现场!!
 *      然后使用CAS，把对象头中的内容替换为线程栈帧中DisplacedMarkWord的地址
 *  场景
 *      在线程1复制对象头Mark Word的同时（CAS之前），线程2也准备获取锁，也复制了对象头Mark Word
 *      在线程2进行CAS时，发现线程1已经把对象头换了，线程2的CAS失败，线程2会尝试使用自旋锁来等待线程1释放锁
 *  轻量级锁的适用场景：线程交替执行同步块，绝大部分的锁在整个同步周期内都不存在长时间的竞争
 *
 * 3.自旋锁 / 重量级锁
 *  轻量级锁CAS抢占失败，线程将会被挂起进入阻塞状态
 *      如果正在持有锁的线程在很短的时间内释放锁资源，那么进入阻塞状态的线程被唤醒后又要重新抢占锁资源
 *  JVM提供了自旋锁，可以通过自旋的方式不断尝试获取锁，从而_避免线程被挂起阻塞_
 *  自旋锁重试之后如果依然抢锁失败，同步锁会升级至重量级锁，锁标志位为10
 *      在这个状态下，未抢到锁的线程都会进入Monitor，之后会被阻塞在WaitSet中
 *  在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能
 *      一旦锁竞争激烈或者锁占用的时间过长，自旋锁将会导致大量的线程一直处于CAS重试状态，占用CPU资源
 *  在高并发的场景下，可以通过关闭自旋锁来优化系统性能
 *
 */
public class SynchronizedDemo {

    /**
     * 修饰代码块
     * 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置
     *
     * 在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。
     * 在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
     *
     * 线程将持有该Monitor对象，进入monitorexit指令，线程将释放该Monitor对象
     */
    public void method() {
        synchronized (this) {
            System.out.println("synchronized 代码块");
        }
    }

    /**
     * 修饰方法
     * 使用ACC_SYNCHRONIZED标示，指明了该方法是一个同步方法。
     * JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用
     *
     * 执行线程会将先尝试持有Monitor对象，再执行方法，方法执行完成后，最后释放Monitor对象
     */
	public synchronized void method2() {
		System.out.println("synchronized 方法");
	}

}

//javac SynchronizedDemo.java
//javap -c -s -v -l SynchronizedDemo.class

